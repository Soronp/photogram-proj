#!/usr/bin/env python3
"""
mesh_cleanup.py

MARK-2 Mesh Cleanup Stage
------------------------
- Cleans and stabilizes raw mesh generated by gen_mesh
- Removes degenerate geometry, floating shells, and small components
- Optional smoothing and decimation (config-driven, deterministic)
- Input : mesh/mesh_raw.ply
- Output: mesh/mesh_cleaned.ply
"""

import json
from pathlib import Path
from typing import Optional

import numpy as np
import open3d as o3d

from utils.paths import ProjectPaths
from utils.config import load_config


# ------------------------------------------------------------------
# Mesh cleanup pipeline
# ------------------------------------------------------------------
def run(project_root: Path, force: bool, logger):
    project_root = project_root.resolve()
    paths = ProjectPaths(project_root)
    config = load_config(project_root)

    mesh_dir = paths.mesh
    mesh_in = mesh_dir / "mesh_raw.ply"
    mesh_out = mesh_dir / "mesh_cleaned.ply"
    report_out = mesh_dir / "mesh_cleanup_report.json"

    logger.info("=== Mesh Cleanup Stage ===")
    logger.info(f"Input mesh : {mesh_in}")
    logger.info(f"Output mesh: {mesh_out}")

    if not mesh_in.exists():
        raise FileNotFoundError(f"Raw mesh not found: {mesh_in}")

    if mesh_out.exists() and not force:
        logger.info("Cleaned mesh already exists â€” skipping")
        return

    # --------------------------------------------------
    # Load mesh
    # --------------------------------------------------
    mesh = o3d.io.read_triangle_mesh(str(mesh_in))
    if not mesh.has_triangles():
        raise RuntimeError("Input mesh contains no triangles")

    mesh.compute_vertex_normals()
    logger.info(
        f"Loaded mesh: {len(mesh.vertices):,} vertices, {len(mesh.triangles):,} triangles"
    )

    # --------------------------------------------------
    # Mandatory topology cleanup
    # --------------------------------------------------
    mesh.remove_degenerate_triangles()
    mesh.remove_duplicated_triangles()
    mesh.remove_duplicated_vertices()
    mesh.remove_non_manifold_edges()
    mesh.remove_unreferenced_vertices()

    # --------------------------------------------------
    # Connected component analysis (AREA-AWARE)
    # --------------------------------------------------
    logger.info("Analyzing connected components (surface-area based)")

    tri_clusters, cluster_n_tris, _ = mesh.cluster_connected_triangles()
    tri_clusters = np.asarray(tri_clusters)
    cluster_n_tris = np.asarray(cluster_n_tris)

    triangles = np.asarray(mesh.triangles)
    vertices = np.asarray(mesh.vertices)

    def triangle_area(tri):
        a, b, c = vertices[tri]
        return 0.5 * np.linalg.norm(np.cross(b - a, c - a))

    tri_areas = np.array([triangle_area(t) for t in triangles])

    cluster_areas = {}
    for idx, c in enumerate(tri_clusters):
        cluster_areas.setdefault(c, 0.0)
        cluster_areas[c] += tri_areas[idx]

    main_cluster = max(cluster_areas, key=cluster_areas.get)
    main_area = cluster_areas[main_cluster]

    logger.info(f"Main component: cluster {main_cluster} (area={main_area:.3f})")

    # --------------------------------------------------
    # Remove floating components
    # --------------------------------------------------
    keep_largest = bool(config.get("mesh_keep_largest_component", True))
    min_area_ratio = float(config.get("mesh_min_component_area_ratio", 0.01))

    remove_tris = [
        tri_idx for tri_idx, cluster_id in enumerate(tri_clusters)
        if keep_largest and cluster_id != main_cluster
        and cluster_areas[cluster_id] < main_area * min_area_ratio
    ]

    logger.info(f"Removing {len(remove_tris):,} triangles from floating components")

    mesh.remove_triangles_by_index(remove_tris)
    mesh.remove_unreferenced_vertices()

    # --------------------------------------------------
    # Optional smoothing
    # --------------------------------------------------
    if config.get("mesh_smoothing", False):
        iters = int(config.get("mesh_smoothing_iterations", 5))
        logger.info(f"Applying Laplacian smoothing ({iters} iterations)")
        mesh = mesh.filter_smooth_laplacian(iters)
        mesh.compute_vertex_normals()

    # --------------------------------------------------
    # Optional decimation
    # --------------------------------------------------
    decimation_ratio: Optional[float] = config.get("mesh_decimation_ratio")
    if decimation_ratio is not None:
        ratio = float(decimation_ratio)
        if 0.0 < ratio < 1.0:
            target = int(len(mesh.triangles) * ratio)
            logger.info(f"Applying decimation (ratio={ratio}, target_tris={target:,})")
            mesh = mesh.simplify_quadric_decimation(target)
            mesh.compute_vertex_normals()

    # --------------------------------------------------
    # Save output
    # --------------------------------------------------
    o3d.io.write_triangle_mesh(str(mesh_out), mesh, write_ascii=False)

    report = {
        "output_vertices": len(mesh.vertices),
        "output_triangles": len(mesh.triangles),
        "kept_main_component": keep_largest,
        "min_area_ratio": min_area_ratio,
    }

    with open(report_out, "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2)

    logger.info("Mesh cleanup completed successfully")


# ------------------------------------------------------------------
# CLI wrapper
# ------------------------------------------------------------------
def main():
    import argparse
    parser = argparse.ArgumentParser(description="MARK-2 Mesh Cleanup")
    parser.add_argument("project_root", type=Path)
    parser.add_argument("--force", action="store_true")
    args = parser.parse_args()

    from utils.logger import get_logger
    logger = get_logger("mesh_cleanup", args.project_root)

    run(args.project_root, args.force, logger)


if __name__ == "__main__":
    main()
